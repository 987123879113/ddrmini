/* SPDX-License-Identifier: Apache-2.0 */

#define VERIFIED_WRITES
// #define EXTENDED_BUFFER

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <types.h>

#include <log.h>

#include <common.h>

#include <mmu.h>

#include <sys-dram.h>
#include <sys-gpio.h>
#include <sys-i2c.h>
#include <sys-sdcard.h>
#include <sys-sid.h>
#include <sys-spi.h>

extern sunxi_i2c_t i2c_pmu;

extern sunxi_sdhci_t sdhci2;

extern uint32_t dram_para[32];

static uint32_t *offset_ptr = (uint32_t*)(0x44A50);
static uint32_t *offset_ptr2 = (uint32_t*)(0x44A54);
static uint32_t *offset_ptr3 = (uint32_t*)(0x44A58);

static uint8_t *read_buffer = (uint8_t*)(0x40000 + 0x4a50 + 0x9b4);

#define START_OFFSET 0

#define CHUNKS_SIZE 0x200
#define WRITE_BUFFER_SIZE 0x8000

#define TIMEOUT_MAX 5

#ifdef VERIFIED_WRITES
uint8_t local_temp_buf[CHUNKS_SIZE];
#endif

static uint8_t local_data_buf[WRITE_BUFFER_SIZE] = {
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
    0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
};


int cmd_write() {
    if (*offset_ptr2 != 0x57357351) {
        *offset_ptr = START_OFFSET;
    }

    *offset_ptr2 = 0x57357351;
    *offset_ptr3 = (uint32_t)&local_data_buf;

    uint32_t cur_block = *offset_ptr;
    uint32_t count = WRITE_BUFFER_SIZE / CHUNKS_SIZE;

    for (uint32_t i = 0; i < count; i++) {
        #ifdef VERIFIED_WRITES
        uint32_t timeout = TIMEOUT_MAX + 1;
        bool firstinit = true;

        while (true) {
            memset(local_temp_buf, 0xff, sizeof(local_temp_buf));
            sdmmc_blk_read(&card0, local_temp_buf, cur_block, 1);

            if (memcmp(local_temp_buf, local_data_buf + (512 * i), 0x200) == 0)
                break;

            if (timeout > TIMEOUT_MAX) {
                timeout = 0;

                if (!firstinit) {
                    mdelay(25);
                }

                sdmmc_blk_write(&card0, local_data_buf + (512 * i), cur_block, 1);
                sdmmc_flush(&card0, &sdhci2);

                firstinit = false;
            } else {
                timeout++;
                mdelay(25);
            }
        }
        #else
            sdmmc_blk_write(&card0, local_data_buf + (512 * i), cur_block, 1);
            sdmmc_flush(&card0, &sdhci2);
        #endif

        cur_block++;
    }

#ifdef EXTENDED_BUFFER
    for (uint32_t i = 0; i < count; i++) {
        #ifdef VERIFIED_WRITES
        uint32_t timeout = TIMEOUT_MAX + 1;
        bool firstinit = true;

        while (true) {
            memset(local_temp_buf, 0xff, sizeof(local_temp_buf));
            sdmmc_blk_read(&card0, local_temp_buf, cur_block, 1);

            if (memcmp(local_temp_buf, read_buffer + (512 * i), 0x200) == 0)
                break;

            if (timeout > TIMEOUT_MAX) {
                timeout = 0;

                if (!firstinit) {
                    mdelay(25);
                }

                sdmmc_blk_write(&card0, read_buffer + (512 * i), cur_block, 1);
                sdmmc_flush(&card0, &sdhci2);

                firstinit = false;
            } else {
                timeout++;
                mdelay(25);
            }
        }
        #else
            sdmmc_blk_write(&card0, read_buffer + (512 * i), cur_block, 1);
            sdmmc_flush(&card0, &sdhci2);
        #endif

        cur_block++;
    }
#endif

    return 0;
}

int main(void) {
    sunxi_clk_init();

    sunxi_clk_dump();

    sunxi_i2c_init(&i2c_pmu);

    pmu_axp1530_init(&i2c_pmu);

    enable_sram_a3();

    printk_info("DRAM: DRAM Size = %dMB\n", sunxi_dram_init(&dram_para));

    sunxi_clk_dump();

    /* Initialize the SD host controller. */
    if (sunxi_sdhci_init(&sdhci2) != 0) {
        printk_error("SMHC: %s controller init failed\n", sdhci2.name);
    } else {
        printk_info("SMHC: %s controller initialized\n", sdhci2.name);
    }

    /* Initialize the SD card and check if initialization is successful. */
    if (sdmmc_init(&card0, &sdhci2) != 0) {
        printk_warning("SMHC: init failed\n");
    } else {
        printk_debug("Card OK!\n");
    }

    cmd_write();

    sdmmc_flush(&card0, &sdhci2);

    return 0;
}